double roll;
		double roll_sqrt = sqrt(BMX160.rawAccelData.rawXData * BMX160.rawAccelData.rawXData + BMX160.rawAccelData.rawZData * BMX160.rawAccelData.rawZData);
		
		if(roll_sqrt != 0.0)
		{
			roll = RADIAN_TO_DEGREE(atan(BMX160.rawAccelData.rawYData / roll_sqrt));
		}
		else
		{
			roll = 0.0;
		}
		
		double pitch = RADIAN_TO_DEGREE(atan2(-BMX160.rawAccelData.rawXData, BMX160.rawAccelData.rawZData));
		
		if((pitch < -90 && KalmanAngleY > 90) || (pitch > 90 && KalmanAngleY < -90))
		{
			KalmanY.angle = pitch;
			KalmanAngleY = pitch;
		}
		else
		{
			KalmanAngleY = Kalman_GetAngle(&KalmanY, pitch, BMX160.rawGyroData.rawYData, Ts_PERIOD);
		}
		
		if(fabs(KalmanAngleY) > 90)
		{
			BMX160.rawGyroData.rawXData = -BMX160.rawGyroData.rawXData;
		}
		
		KalmanAngleX = Kalman_GetAngle(&KalmanX, roll, BMX160.rawGyroData.rawYData, Ts_PERIOD);
		
		
-------------------------------------------------------------------------------------------------


/**------------------------------------------------------------------------------
  * @brief  			
	*	@param[IN]  	
	*	@param[OUT]		
  * @retval 		
  *------------------------------------------------------------------------------*/
double Kalman_GetAngle(Kalman_t * Kalman, double newAngle, double newRate, double dt)
{
	double rate = newRate - Kalman->bias;
	Kalman->angle += dt * rate;
	
	Kalman->P[0][0] += dt * (dt * Kalman->P[1][1] - Kalman->P[0][1] - Kalman->P[1][0] + Kalman->Q_angle);
	Kalman->P[0][1] -= dt * Kalman->P[1][1];
	Kalman->P[1][0] -= dt * Kalman->P[1][1];
	Kalman->P[1][1] += Kalman->Q_bias * dt;
	
	double S = Kalman->P[0][0] + Kalman->R_measure;
	double K[2];
	K[0] = Kalman->P[0][0] / S;
	K[1] = Kalman->P[1][0] / S;
	
	double y = newAngle - Kalman->angle;
	Kalman->angle += K[0] * y;
	Kalman->bias += K[1] * y;
	
	double P00_temp = Kalman->P[0][0];
	double P01_temp = Kalman->P[0][1];
	
	Kalman->P[0][0] -= K[0] * P00_temp;
	Kalman->P[0][1] -= K[0] * P01_temp;
	Kalman->P[1][0] -= K[1] * P00_temp;
	Kalman->P[1][1] -= K[1] * P01_temp;
	
	return Kalman->angle;
}

-----------------------------------------------------------------------------------------------------
double Kalman_GetAngle(Kalman_t * Kalman, double newAngle, double newRate, double dt);
-----------------------------------------------------------------------------------------------------
typedef struct
{
	double Q_angle;
	double Q_bias;
	double R_measure;
	double angle;
	double bias;
	double P[2][2];
	
} Kalman_t;
-----------------------------------------------------------------------------------------------------
static Kalman_t KalmanX = {
	.Q_angle = 0.001f,
	.Q_bias = 0.003f,
	.R_measure = 0.03f
};

static Kalman_t KalmanY = {
	.Q_angle = 0.001f,
	.Q_bias = 0.003f,
	.R_measure = 0.03f,
};